<!doctype html>
<html lang="ja">
<head>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-XFRX8T94YG"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-XFRX8T94YG');
  </script>

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>COLD ROOM RADIO</title>

  <link href="https://fonts.googleapis.com/css2?family=Exo+2:wght@100;200;300;400;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/plyr@3.7.8/dist/plyr.css" />

  <style>
    :root{
      --bg:#0a1620;
      --nebula:#133a4d;
      --accent:#6be3ff;
      --muted:#b3c7d6;
      --glass:rgba(255,255,255,0.08);
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;color:#fff;background:transparent}
    body, p, label, input, textarea, button, h1, h2, h3, h4, h5, h6 {
      font-family:'Exo 2','IBM Plex Sans',system-ui,-apple-system,'Segoe UI',Roboto,'Helvetica Neue',Arial,sans-serif !important;
      font-weight:100;
      letter-spacing:.5px;
    }
    a{color:inherit}

    /* Background layers */
    .bg-wrap{position:fixed;inset:0;z-index:-3;overflow:hidden;background:transparent}
    .bg-layer {
      position: absolute;
      inset: 0;
      background:
        radial-gradient(ellipse at 20% 30%, rgba(255, 90, 255, 0.08), transparent 60%),
        radial-gradient(ellipse at 80% 70%, rgba(0, 255, 190, 0.06), transparent 70%),
        radial-gradient(ellipse at 60% 20%, rgba(180, 100, 255, 0.07), transparent 75%),
        radial-gradient(ellipse at 30% 80%, rgba(120, 255, 180, 0.05), transparent 80%),
        radial-gradient(ellipse at 50% 50%, rgba(255, 180, 255, 0.04), transparent 85%),
        linear-gradient(180deg, #03040a 0%, #050612 60%, #0a101a 100%);
      background-blend-mode: screen, overlay, normal;
      background-size: 200% 200%;
      animation: drift 25s ease-in-out infinite alternate;
    }

    @keyframes drift {
      0% {background-position: 0% 0%;}
      50% {background-position: 50% 50%;}
      100% {background-position: 100% 100%;}
    }

    .grain{position:absolute;inset:0;pointer-events:none;
      background-image:radial-gradient(rgba(255,255,255,0.02) 1px, transparent 1px);
      background-size:4px 4px;mix-blend-mode:overlay;opacity:.5
    }

    .hero{min-height:100vh;display:flex;align-items:center;justify-content:center;text-align:center;padding:24px;}
    .hero h1{font-size:48px;font-weight:100;letter-spacing:1px;margin:0;text-shadow:0 12px 36px rgba(0,0,0,0.6);}
    .logo-mark{width:min(40vw,240px);aspect-ratio:1/1;margin:0 auto 18px auto;display:flex;align-items:center;justify-content:center;opacity:.9;}
    .logo-mark img{max-width:100%;max-height:100%;object-fit:contain}
    .scroll-cue{position:absolute;left:50%;bottom:24px;transform:translateX(-50%);font-size:12px;color:var(--muted);display:flex;flex-direction:column;align-items:center;gap:8px;opacity:.8;}
    .arrow{width:1px;height:24px;background:linear-gradient(180deg,transparent,var(--accent));box-shadow:0 0 12px rgba(107,227,255,0.6);animation:drip 1.4s ease-in-out infinite;}
    @keyframes drip{0%{transform:translateY(0);opacity:.4}50%{transform:translateY(6px);opacity:1}100%{transform:translateY(0);opacity:.4}}

    .wrap{max-width:1100px;margin:0 auto;padding:36px}
    @media (max-width:720px){.wrap{padding:20px}.hero h1{font-size:32px}}

    .lead{margin:12px auto 0 auto;max-width:780px;color:#e7f6fb;opacity:.9;line-height:1.7}
    .card{margin-top:28px;padding:20px;border-radius:16px;background:linear-gradient(135deg,rgba(255,255,255,0.08),rgba(255,255,255,0.02));backdrop-filter:blur(14px) saturate(160%);-webkit-backdrop-filter:blur(14px) saturate(160%);border:1px solid rgba(255,255,255,0.12);box-shadow:0 8px 32px rgba(0,0,0,0.6), inset 0 0 40px rgba(43,209,234,0.05);}
    .section-title{font-size:20px;font-weight:200;margin:0 0 8px 0;color:var(--accent);}
    .plyr--audio .plyr__controls{background:transparent !important;color:var(--muted)}
    .plyr--audio .plyr__control{background:var(--glass) !important;border-radius:50%;transition:background .3s,color .3s;}
    .plyr--audio .plyr__control:hover{background:var(--accent) !important;color:#000 !important}

    .now{max-width:1100px;padding:10px;border-radius:8px;background:rgba(255,255,255,0.05);}
    .now .label{font-size:13px;color:var(--muted)}
    .now .title{font-weight:600;margin-top:4px}
    .now .desc{font-size:13px;color:var(--muted);margin-top:6px}
    
  .now, .episode { position: relative; }

    /* Sparkle visuals */
    .sparkle {
      position: absolute;
  border-radius: 50%;
      pointer-events: none;
      --spark-color: var(--accent);
  background: radial-gradient(circle, rgba(255,250,230,0.98) 0%, rgba(255,255,255,0.85) 40%, transparent 70%);
      box-shadow: 0 0 8px var(--spark-color),
                  0 0 16px rgba(107,227,255,0.6);
  animation: sparkleFloat var(--spark-duration,2.4s) ease-out forwards;
  opacity: 0;
    }

    @keyframes sparkleFloat {
      0% {
        transform: translate(0,6px) scale(0.4);
        opacity: 0;
      }
      8% {
        opacity: 0.18;
      }
      60% {
        opacity: 0.9;
      }
      100% {
        transform: translate(var(--x,0), var(--y,-80px)) scale(0.6) rotate(calc(var(--curve,0) * 1deg));
        opacity: 0;
      }
    }

    .sparkle-circle, .sparkle-triangle {
      position: absolute;
      opacity: 0;
      pointer-events: none;
      will-change: transform, opacity;
    }

    .sparkle-circle { background: radial-gradient(circle, #fff, transparent 60%); border-radius: 50%; }

    .sparkle, .sparkle * {
      overflow: visible !important;
    }

    .heart-btn { overflow: visible; }

  /* Triangle sparkles */
  .sparkle-triangle {
      width: 0;
      height: 0;
      transform-origin: center bottom;
      filter: drop-shadow(0 0 3px rgba(255,255,255,0.4));
      z-index:10000;
      opacity:0;
      animation: sparkleFloat var(--spark-duration,2.4s) ease-out forwards;
      background: transparent;
      border-left: 0 solid transparent;
      border-right: 0 solid transparent;
      border-bottom: 0 solid transparent;
    }

    .sparkle.sparkle-triangle {
      background: transparent !important;
      border-radius: 0 !important;
      box-shadow: none !important;
      background-image: none !important;
    }

  /* Triangle colors */
    .tri-blue { border-bottom-color: rgba(107,227,255,0.96) !important; }
    .tri-soft { border-bottom-color: rgba(255, 245, 138, 0.92) !important; }
    .tri-pink { border-bottom-color: rgba(255,180,255,0.92) !important; }

    
    .episodes{display:flex;flex-direction:column;gap:10px;max-width:1100px}
    .episode{display:flex;align-items:center;gap:14px;padding:12px;border-radius:10px;background:linear-gradient(180deg,rgba(255,255,255,0.01),transparent);border:1px solid rgba(255,255,255,0.05);cursor:pointer;transition:transform .18s, border-color .18s;}
    .episode:hover{transform:translateY(-3px);border-color:rgba(255,255,255,0.12)}
    .episode .meta{flex:1}
    .episode .title{font-weight:600}
    .episode .date{font-size:13px;color:var(--muted)}
    .episode.disabled{cursor:not-allowed;opacity:.7}
    .episode .status{font-size:13px;color:var(--muted)}

    /* Heart wrapper */
    .heart-wrap {
      margin-left: auto;
      display: flex;
      align-items: center;
      padding-left: 12px;
      border-left: 1px solid rgba(255,255,255,0.06);
    }

    .heart-btn {
      position: relative;
      z-index: 10;
  background: transparent !important;
      border: none;
      cursor: pointer;
      padding: 8px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
    }

    .heart-btn svg { width:18px; height:18px; display:block; }
  .heart-btn:focus { outline: none; }
  .heart-btn:focus-visible { box-shadow: 0 0 0 4px rgba(107,227,255,0.08); border-radius: 8px; }
  .heart-btn svg { shape-rendering: geometricPrecision; }
    .heart-btn svg path { fill: none; stroke: #fff; stroke-width: 1; transition: all .18s ease; }
    .heart-btn:hover svg path { stroke: var(--accent); transform: scale(1.06); }
    .heart-btn.active svg path { fill: #ff7ca8; stroke: #ff3f72; filter: drop-shadow(0 0 6px rgba(255,90,150,0.6)); transform: scale(1.08); }

    .heart-btn.disabled {
      opacity: 0.4;
      cursor: not-allowed;
      pointer-events: none;
      background: transparent !important;
    }

    .heart-btn.disabled svg { stroke: #aaa; fill: none; }

    /* Larger touch target on small screens */
    @media (max-width:720px) {
      .heart-btn { padding: 14px; }
      .heart-btn svg { width: 22px; height: 22px; }
      .heart-wrap { padding-left: 16px; }
    }

    /* Now-playing horizontal layout */
    .now { display: block; }
    .now .label { display:block; width:100%; }
    .now .bar { display:flex; align-items:center; gap:12px; margin-top:8px }
    .now .heart-wrap { align-items: center; }
    .now .now-meta { display:flex; flex-direction:column; gap:6px; flex:1 }
    @media (min-width:721px) {
      .now { display:block }
    }

    form.contact{margin-top:12px;padding:16px;border-radius:10px;background:linear-gradient(180deg,rgba(255,255,255,0.015),rgba(0,0,0,0.06));border:1px solid rgba(255,255,255,0.03)}
    .field{display:flex;flex-direction:column;margin-bottom:12px}
    label{font-size:13px;color:var(--muted);margin-bottom:6px}
    input[type=text],input[type=email],textarea{padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.02);color:#fff}
    textarea{min-height:120px;resize:vertical}
    button{background:linear-gradient(90deg,var(--accent),#7af5ff);border:0;padding:10px 14px;border-radius:10px;font-weight:600;cursor:pointer}

    footer{margin-top:36px;color:var(--muted);font-size:13px;display:flex;justify-content:space-between;align-items:center}
    .socials a{margin-left:8px;text-decoration:none;color:var(--muted)}

    /* FAQ */
    .faq-item {
    border-top: 1px solid rgba(255,255,255,0.08);
    padding: 10px 0;
    }
    .faq-question {
    cursor: pointer;
    font-weight: 300;
    color: var(--accent);
    transition: color 0.3s;
    display: flex;
    justify-content: space-between;
    align-items: center;
    }
    .faq-question::after {
    content: "+";
    color: var(--muted);
    transition: transform 0.3s;
    }
    .faq-item.active .faq-question::after {
    content: "−";
    color: var(--accent);
    }
    .faq-answer {
    display: none;
    margin-top: 6px;
    line-height: 1.8;
    color: #e7f6fb;
    font-weight: 200;
    opacity: 0.9;
    }
    .faq-item.active .faq-answer {
    display: block;
    }
  </style>
</head>
<body>

  <div class="bg-wrap" aria-hidden="true">
    <div class="bg-layer"></div>
    <div class="grain"></div>
  </div>
  <canvas id="stars" style="position:fixed;inset:0;z-index:-2;pointer-events:none;"></canvas>

  <section class="hero" id="top">
    <div>
      <div class="logo-mark"><img src="logo.png" alt="Cold Room Radio logo"></div>
      <p class="lead">
        記憶と記録が交差する場所──<br>
        『<b>P</b>arallel・<b>T</b>ime・<b>A</b>rchiveのCold Room』へようこそ。<br>
        Perfumeがコールドスリープしている間、ファン同士が気持ちを交わし、想いを共有する<br>
        非公式ファンレイディオ番組です。
      </p>
    </div>
    <div class="scroll-cue" aria-hidden="true">
      <div>スクロールしてみて</div>
      <div class="arrow"></div>
    </div>
  </section>

  <main class="wrap" id="main">
    <section class="card" aria-label="プレイヤー">
      <h2 class="section-title">再生</h2>
      <div id="player-wrap">
        <audio id="audio-player" controls crossorigin playsinline style="width:100%;">
          <source id="audio-source" src="https://dn720703.ca.archive.org/0/items/cold-room-radio-episode-01-coldsleep/Cold%20Room%20Radio%20-%20Episode%2001%20-%20coldsleep.mp3" type="audio/mpeg" data-title="#1 <cold sleep>">
          あなたのブラウザは audio をサポートしていません。
        </audio>
      </div>
      <div class="now" style="margin-top:14px;">
        <div class="label">最新のエピソード</div>
        <div class="bar">
          <div class="now-meta">
            <div id="now-title" class="title">#1 <cold sleep></div>
            <div id="now-desc" class="desc">2025/10/10 公開</div>
          </div>
          <div class="heart-wrap">
            <button class="heart-btn" data-episode="current">
              <svg viewBox="0 0 24 24">
                <path d="M12 21s-6.9-5.5-9.5-9.1C.9 9.6 1.2 6.3 3.6 4.4 5.7 2.8 8.6 3.1 10.3 5c.3.4.6.7.9 1 .3-.3.6-.6.9-1 1.7-1.9 4.6-2.2 6.7-.6 2.4 1.9 2.7 5.2 1.1 7.5C18.9 15.5 12 21 12 21z"/>
              </svg>
            </button>
          </div>
        </div>
      </div>
    </section>

    <section class="card" aria-label="エピソード一覧">
      <h2 class="section-title">エピソード</h2>
      <div class="episodes" id="episodes-list"></div>
    </section>

    <section class="card" aria-label="メッセージフォーム">
      <h2 class="section-title">メッセージを送る</h2>
        <form class="contact" id="contact-form" action="https://formspree.io/f/mzzjqrwy" method="POST">
        <input type="hidden" name="_subject" value="[Cold Room Radio] 新しいメッセージ">
        <input type="hidden" name="_next" value="https://coldroomradio.github.io/coldroomradio/thanks.html">
        <div class="field"><label for="name">お名前（任意）</label><input id="name" name="name" type="text" placeholder="ラジオネームでOK"></div>
        <div class="field"><label for="email">メールアドレス（任意）</label><input id="email" name="email" type="email" placeholder="連絡が必要な場合のみ"></div>
        <div class="field"><label for="message">メッセージ</label><textarea id="message" name="message" placeholder="感想や記憶、思い出をお寄せください"></textarea></div>
        <input type="text" name="_gotcha" style="display:none" tabindex="-1" autocomplete="off">
        <div style="display:flex;gap:8px;align-items:center"><button type="submit">送信する</button><div style="color:var(--muted);font-size:13px">※返信が必要な場合はメールアドレスを書いてください</div></div>
      </form>

      <footer>
        <div>© Cold Room Radio — 非公式ファンレイディオ</div>
        <div class="socials"><a href="https://x.com/coldroomradio" target="_blank">X @coldroomradio</a><a href="https://instagram.com/coldroomradio" target="_blank">Instagram</a></div>
      </footer>
    </section>

    <!-- FAQ -->
    <section class="card" aria-label="よくある質問">
      <h2 class="section-title">よくある質問</h2>
      <div class="faq">
        <div class="faq-item"><div class="faq-question">え、これ何？</div><div class="faq-answer">Cold Room Radioは Perfume がコールドスリープ中の期間も好きな気持ちを交わせる場として立ち上げた、<br>「非公式」のオンラインレイディオ番組です。</br></div></div>
        <div class="faq-item"><div class="faq-question">何かのサブスク？お金かかるの？</div><div class="faq-answer">多くの方と「気持ちを交わしたい」「想いを共有したい」という思いから、<br>広告は一切入れず、無料でお聴きいただけるようにしています。</br>スポンサーやPR枠は設けていません。<br>ただし、番組トーク内で純粋に好きなものや良いと思ったものを紹介することはあります。</div></div>
        <div class="faq-item"><div class="faq-question">今後有料コンテンツかなんか作ってそこに誘導する感じ？</div><div class="faq-answer">いいえ。このホームページで聴ける番組だけです。</div></div>
        <div class="faq-item"><div class="faq-question">へー...ってか誰？</div><div class="faq-answer">ただのファンです。関係者ではありません。</div></div>
        <div class="faq-item"><div class="faq-question">で、そのParallel Time Archiveって何？</div><div class="faq-answer">時空を超えて旅する者たちの記録を保管する機関です。<br>(私たちに馴染みのある文字を使って設定を入れてみたかっただけです)</br></div></div>
        <div class="faq-item"><div class="faq-question">Cold Roomとは？</div><div class="faq-answer">Perfumeのコールドcapsuleが保管されている場所です。<br>私たちがこのRoomでスリープ明けまで暖かく3人を見守っているという独自の設定です。</br></div></div>
        <div class="faq-item"><div class="faq-question">新しいのはいつアップされるの？</div><div class="faq-answer">週一の更新を予定しています。<br>お手紙やイラストの投稿が多い時は、もう少し頻繁に更新するかもしれません。</br></div></div>
      </div>
    </section>
  </main>

    <script>
    document.querySelectorAll('.faq-question').forEach(q => {
        q.addEventListener('click', () => {
        q.parentElement.classList.toggle('active');
        });
    });
    </script>


    <!-- Plyr script -->
  <script src="https://cdn.jsdelivr.net/npm/plyr@3.7.8/dist/plyr.polyfilled.js"></script>

  <!-- episodes data (editable): loads window.EPISODE_LIST -->
  <script src="./episode-list.html"></script>

  <script>
      // Load episodes from external `episode-list.html` which defines window.EPISODE_LIST
      // If that file isn't present or EPISODE_LIST is not defined, fall back to an empty list.
      function parseReleaseAtToDate(s) {
        if (!s) return null;
        try {
          // Let the browser parse an ISO string with timezone if provided
          const d = new Date(s);
          if (!isNaN(d)) return d;
        } catch (e) {}
        // fallback: try yyyy/mm/dd or yyyy-mm-dd
        const parts = s.match(/^(\d{4})[-\/](\d{1,2})[-\/](\d{1,2})/);
        if (parts) return new Date(Number(parts[1]), Number(parts[2]) - 1, Number(parts[3]), 0, 0, 0);
        return null;
      }

      function nowInJST() {
        // return a Date object representing current time
        return new Date();
      }

      const rawEpisodes = window.EPISODE_LIST || [];
      const elList = document.getElementById('episodes-list');
      const episodes = rawEpisodes.map(ep => {
        // compute released by comparing now to release_at (if present)
        const releaseDate = parseReleaseAtToDate(ep.release_at || ep.date || null);
        let released = !!ep.released;
        if (releaseDate) {
          // release when current time is >= releaseDate; releaseDate may include timezone offset
          released = (nowInJST().getTime() >= releaseDate.getTime());
        }
        return Object.assign({}, ep, { released });
      });

      episodes.forEach(ep => {
        const div = document.createElement('div');
          div.className = 'episode' + (!ep.released ? ' disabled' : '');
          div.dataset.episode = `ep${ep.id}`;

        const meta = document.createElement('div');
        meta.className = 'meta';

        const title = document.createElement('div');
        title.className = 'title';
        title.textContent = `#${ep.id} ${ep.title}`;

        const date = document.createElement('div');
        date.className = 'date';
        date.textContent = ep.date || '';

        meta.appendChild(title);
        meta.appendChild(date);

        const status = document.createElement('div');
        status.className = 'status';
        status.textContent = ep.desc;

  // place heart to the far right to avoid accidental play clicks
  const heartWrap = document.createElement('div');
  heartWrap.className = 'heart-wrap';
  const heart = document.createElement('button');
  heart.className = 'heart-btn' + (!ep.released ? ' disabled' : '');
  // store a concise key so now and list can reference same liked key
  const episodeKey = `ep${ep.id}`;
  heart.dataset.episode = episodeKey;
  // prevent heart clicks from bubbling and triggering the episode click (which loads the episode)
  heart.addEventListener('click', (e) => { e.stopPropagation(); });
        heart.innerHTML = `
          <svg viewBox="0 0 24 24">
            <path d="M12 21s-6.9-5.5-9.5-9.1C.9 9.6 1.2 6.3 3.6 4.4 5.7 2.8 8.6 3.1 10.3 5c.3.4.6.7.9 1 .3-.3.6-.6.9-1 1.7-1.9 4.6-2.2 6.7-.6 2.4 1.9 2.7 5.2 1.1 7.5C18.9 15.5 12 21 12 21z"/>
          </svg>
        `;

  heartWrap.appendChild(heart);
        div.appendChild(meta);
        div.appendChild(status);
        div.appendChild(heartWrap);

        // Only make clickable if released
        if (ep.released && ep.src) {
          div.addEventListener('click', () => loadEpisode(ep));
        }

        elList.appendChild(div);
      });


      const plyr = new Plyr('#audio-player', {
        controls: ['play','progress','current-time','mute','volume']
      });

  // track currently playing row key so we can hide it from the list
  let currentPlayingKey = null;

  // helper: set visual state of all hearts for an episodeKey
      function syncHeartState(episodeKey, label) {
        const key = `liked_${episodeKey}`;
        const liked = localStorage.getItem(key) === 'true';
        document.querySelectorAll(`.heart-btn[data-episode="${episodeKey}"]`).forEach(b => {
          if (liked) b.classList.add('active'); else b.classList.remove('active');
          // expose pressed state for assistive tech
          try { b.setAttribute('aria-pressed', liked ? 'true' : 'false'); } catch(e){}
          if (label && !b.getAttribute('aria-label')) b.setAttribute('aria-label', label + ' をいいね');
        });
      }

      // helper: toggle like state and sync UI + analytics + sparkles on the clicked button
      function toggleLike(episodeKey, label, clickedBtn) {
        const key = `liked_${episodeKey}`;
        const willLike = !(localStorage.getItem(key) === 'true');
        if (willLike) localStorage.setItem(key, 'true'); else localStorage.removeItem(key);
        // update all UI
        syncHeartState(episodeKey, label);

        // Send GA4-friendly event and push helpful debug info
        try {
          const gaEventName = willLike ? 'like' : 'like_removed';
          const gaParams = {
            content_id: episodeKey,
            content_title: label || episodeKey,
            content_type: 'episode',
            method: 'button'
          };

          if (window.gtag) {
            gtag('event', gaEventName, gaParams);
            console.debug('GA event sent:', gaEventName, gaParams);
          } else {
            console.debug('gtag() not available — would send:', gaEventName, gaParams);
          }

          // also push to dataLayer for debugging/inspection
          window.dataLayer = window.dataLayer || [];
          window.dataLayer.push(Object.assign({ event: gaEventName, liked: willLike }, gaParams));
        } catch (e) {
          console.warn('Error sending GA event', e);
        }

  if (willLike && clickedBtn) {
          // pooled sparkles: create/get nodes and animate via CSS variables
          const POOL_MAX = 40;
          window.__sparklePool = window.__sparklePool || [];

          function createNode() {
            const el = document.createElement('div');
            el.className = 'sparkle';
            el.style.position = 'absolute';
            el.style.pointerEvents = 'none';
            el.style.zIndex = '9999';
            document.body.appendChild(el);
            return el;
          }

          function getNode() {
            for (let n of window.__sparklePool) if (!n.__inUse) { n.__inUse = true; return n; }
            if (window.__sparklePool.length < POOL_MAX) {
              const n = createNode(); n.__inUse = true; window.__sparklePool.push(n); return n;
            }
            const n = window.__sparklePool[Math.floor(Math.random() * window.__sparklePool.length)];
            n.__inUse = true; return n;
          }

          function releaseNode(n) {
            // reset to neutral state so node can be reused safely
            n.className = 'sparkle';
            n.style.left = '';
            n.style.top = '';
            n.style.width = '';
            n.style.height = '';
            n.style.borderLeft = '';
            n.style.borderRight = '';
            n.style.borderBottom = '';
            n.style.background = '';
            n.innerHTML = '';
            n.style.animationDelay = '';
            n.style.animationDuration = '';
            n.style.transform = '';
            n.style.zIndex = '';
            n.classList.remove('sparkle-triangle');
            if (n.__releaseTimeout) { clearTimeout(n.__releaseTimeout); n.__releaseTimeout = null; }
            n.__inUse = false;
          }

          const rect = clickedBtn.getBoundingClientRect();
          const docOffsetX = window.pageXOffset || document.documentElement.scrollLeft || 0;
          const docOffsetY = window.pageYOffset || document.documentElement.scrollTop || 0;
          const baseX = rect.left + rect.width / 2 + docOffsetX;
          const baseY = rect.top + rect.height / 2 + docOffsetY;

          const emitCount = 14;
          for (let i = 0; i < emitCount; i++) {
            const node = getNode();
            const isTriangle = Math.random() < 0.42;
            if (isTriangle) node.classList.add('sparkle-triangle'); else node.classList.add('sparkle-circle');

            // start near the heart center with a tiny jitter so particles overlap nicely
            const jitterX = (Math.random() - 0.5) * rect.width * 0.3;
            const jitterY = (Math.random() - 1.5) * rect.height * 0.3;
            node.style.left = (baseX + jitterX) + 'px';
            node.style.top = (baseY + jitterY) + 'px';

            const size = Math.random() * 12 + 3;
            if (isTriangle) {
              const variant = Math.random();
              const colors = [
                'rgba(107,227,255,0.96)',
                'rgba(159,223,255,0.92)',
                'rgba(255,180,255,0.92)'
              ];
              const fill = colors[Math.floor(Math.random()*colors.length)];

              node.style.width = `${Math.round(size+2)}px`;
              node.style.height = `${Math.round(size+2)}px`;
              node.style.background = 'transparent';
              node.style.borderLeft = '';
              node.style.borderRight = '';
              node.style.borderBottom = '';

              if (variant < 0.5) {
                const w = Math.round(size+2);
                const h = Math.round(size+2);
                const strokeW = Math.max(1, Math.round((size+2) * 0.18));
                node.innerHTML = `<svg viewBox="0 0 ${w} ${h}" width="${w}" height="${h}" style="display:block;overflow:visible" xmlns="http://www.w3.org/2000/svg"><polygon points="${w/2},0 ${w},${h} 0,${h}" fill="none" stroke="${fill}" stroke-width="${strokeW}" stroke-linejoin="round" vector-effect="non-scaling-stroke" /></svg>`;
              } else {
                const w = Math.round(size+2);
                const h = Math.round(size+2);
                const strokeW = Math.max(1, Math.round((size+2) * 0.18));
                node.innerHTML = `<svg viewBox="0 0 ${w} ${h}" width="${w}" height="${h}" style="display:block;overflow:visible" xmlns="http://www.w3.org/2000/svg"><polygon points="0,0 ${w},0 0,${h}" fill="none" stroke="${fill}" stroke-width="${strokeW}" stroke-linejoin="round" vector-effect="non-scaling-stroke" /></svg>`;
              }
              // mark as triangle for animation rules
              node.classList.add('sparkle-triangle');
            } else {
              // smaller, single-color round sparkles (soft warm white)
              const small = Math.max(2, size * 0.7);
              node.style.width = `${small}px`;
              node.style.height = `${small}px`;
              node.style.background = `radial-gradient(circle, rgba(255,250,230,0.98) 0%, rgba(255,255,255,0.7) 48%, transparent 75%)`;
            }

            // emit outward from the heart: pick an angle and distance, convert to x/y
            const angle = Math.random() * Math.PI * 2;
            const minDist = 28 + Math.random() * 8;
            const maxDist = 60 + Math.random() * 30;
            const dist = minDist + Math.random() * (maxDist - minDist);
            const dx = Math.cos(angle) * dist;
            const dy = Math.sin(angle) * dist;
            node.style.setProperty('--x', dx + 'px');
            node.style.setProperty('--y', dy + 'px');
            node.style.setProperty('--curve', (Math.random() * 56 - 28).toString());

            // slightly longer, more consistent durations so sparks linger
            const dur = 2.4 + Math.random() * 0.8; // 2.4 - 3.2s
            // Ensure animation restarts when node is reused: clear animation, force reflow, then set durations
            node.style.animation = 'none';
            // force reflow
            void node.offsetWidth;
            node.style.animationDuration = `${dur}s`;
            node.style.animationDelay = `${Math.random() * 0.35}s`;
            // allow CSS to pick up the base animation name again
            node.style.animation = '';

            if (node.__releaseTimeout) clearTimeout(node.__releaseTimeout);
            node.__releaseTimeout = setTimeout(() => releaseNode(node), (dur + 0.6) * 1000 + Math.random() * 300);
          }
          try { clickedBtn.setAttribute('aria-pressed', willLike ? 'true' : 'false'); } catch(e){}
        }
      }

      function loadEpisode(ep){
        const srcEl = document.getElementById('audio-source');
        const audioEl = document.getElementById('audio-player');
        if(!ep.src){
          alert('このエピソードの音源URLがまだ設定されていません。');
          return;
        }
        srcEl.src = ep.src;
        audioEl.load();
          // set playing key before initiating play so analytics can read it
          const episodeKey = `ep${ep.id}`;
          window.currentPlayingKey = episodeKey;
          // update Now Heart Button
          const nowHeart = document.querySelector('.now .heart-btn');
          if (nowHeart) {
            nowHeart.dataset.episode = episodeKey;
            nowHeart.dataset.title = `#${ep.id} ${ep.title}`;
            if (!nowHeart.getAttribute('aria-label')) nowHeart.setAttribute('aria-label', `いいね #${ep.id} ${ep.title}`);
            const stored = localStorage.getItem(`liked_${episodeKey}`) === 'true';
            try { nowHeart.setAttribute('aria-pressed', stored ? 'true' : 'false'); } catch(e){}
          }
          plyr.play();
  document.getElementById('now-title').textContent = `#${ep.id} ${ep.title}`;
  document.getElementById('now-desc').textContent = ep.desc || '';
  // send a lightweight GA event for the manual load (older code sent a play here)
  try { if (window.gtag) gtag('event', 'load_episode', { event_category:'audio', event_label: ep.title, content_id: `ep${ep.id}` }); } catch(e){}

  // Sync UI state for the now heart (already set above). Ensure all trackers see the same key.
  syncHeartState(episodeKey, ep.title);

        // hide the matching episode row from the list to avoid duplicate entry
        try {
          if (currentPlayingKey && currentPlayingKey !== episodeKey) {
            const prev = document.querySelector(`.episode[data-episode="${currentPlayingKey}"]`);
            if (prev) prev.style.display = '';
          }
          const el = document.querySelector(`.episode[data-episode="${episodeKey}"]`);
          if (el) el.style.display = 'none';
          currentPlayingKey = episodeKey;
          window.currentPlayingKey = episodeKey;
        } catch (err) {
          console.warn('Could not hide/show episode row', err);
        }
      }

      const latestReleased = episodes.findLast(ep => ep.released && ep.src);
      if (latestReleased) {
        // pre-set currentPlayingKey so the initial automatic play/load is associated
        window.currentPlayingKey = `ep${latestReleased.id}`;
        loadEpisode(latestReleased);
      }


      // Starfield
        const canvas = document.getElementById('stars');
        const ctx = canvas.getContext('2d');
        let stars = [];
        function resizeStars() {
        const dpr = window.devicePixelRatio || 1;
        canvas.width = window.innerWidth * dpr;
        canvas.height = window.innerHeight * dpr;
        canvas.style.width = window.innerWidth + 'px';
        canvas.style.height = window.innerHeight + 'px';
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);
        stars = Array.from({length: 90}, () => ({
            x: Math.random() * window.innerWidth,
            y: Math.random() * window.innerHeight,
            r: Math.random() * 0.8 + 0.2,
            tw: Math.random() * Math.PI * 2,
            tws: Math.random() * 0.03 + 0.01
        }));
        }
        window.addEventListener('resize', resizeStars);
        resizeStars();
        function drawStars() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        stars.forEach(s => {
            s.tw += s.tws;
            const alpha = 0.5 + 0.5 * Math.sin(s.tw);
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.beginPath();
            ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
            ctx.fillStyle = '#fff';
            ctx.shadowColor = '#2bd1ea';
            ctx.shadowBlur = 8 * alpha;
            ctx.fill();
            ctx.restore();
        });
        requestAnimationFrame(drawStars);
        }
        drawStars();

      /* ------------------------------
          GA4 Enhanced Audio Tracking (episode-linked)
         ------------------------------ */
      document.addEventListener('DOMContentLoaded', function() {
        const player = document.getElementById('audio-player');
        const plyrInstance = plyr;
        const checkpoints = [25, 50, 75, 90];
        const sent = {};
        let lastTime = 0;
        let listenStart = null;

        function getEpisodeInfo() {
          // prefer explicit currentPlayingKey, then now heart dataset, then fallback to source filename
          const nowHeart = document.querySelector('.now .heart-btn');
          const srcEl = document.getElementById('audio-source');
          const title = document.getElementById('now-title')?.textContent || srcEl?.dataset?.title || srcEl?.src?.split('/').pop() || 'unknown';
          const id = (window.currentPlayingKey) || (nowHeart && nowHeart.dataset && nowHeart.dataset.episode) || null;
          return { id: id || 'unknown', title };
        }

        function pushGtag(eventName, params = {}) {
          // ensure we always attach helpful defaults
          const ep = getEpisodeInfo();
          const base = {
            event_category: 'audio',
            content_type: 'episode',
            content_id: ep.id,
            content_title: ep.title
          };
          const payload = Object.assign({}, base, params);
          if (window.gtag) {
            try { gtag('event', eventName, payload); } catch (e) { console.warn('gtag error', e); }
          }
          // always push to dataLayer for visibility even if gtag isn't ready
          window.dataLayer = window.dataLayer || [];
          window.dataLayer.push(Object.assign({ event: eventName }, payload));
          console.debug('GA event:', eventName, payload);
        }

        function sendListenTime() {
          if (!listenStart) return;
          const sec = Math.floor((Date.now() - listenStart) / 1000);
          listenStart = null;
          if (sec > 2) pushGtag('listen_time', { seconds_listened: sec });
        }

        // Wire player events with episode-aware params
        plyrInstance.on('play', () => {
          listenStart = Date.now();
          pushGtag('play', { position_sec: Math.floor(player.currentTime) });
        });

        plyrInstance.on('pause', () => {
          sendListenTime();
          pushGtag('pause', { position_sec: Math.floor(player.currentTime) });
        });

        plyrInstance.on('seeked', () => {
          pushGtag('seek', { from_sec: Math.floor(lastTime), to_sec: Math.floor(player.currentTime) });
        });

        plyrInstance.on('ended', () => {
          sendListenTime();
          pushGtag('complete', { duration_sec: Math.floor(player.duration), position_sec: Math.floor(player.currentTime) });
        });

        plyrInstance.on('timeupdate', () => {
          if (!player.duration) return;
          const percent = (player.currentTime / player.duration) * 100;
          checkpoints.forEach(cp => {
            if (percent >= cp && !sent[cp]) {
              pushGtag('progress', { milestone_pct: cp, position_sec: Math.floor(player.currentTime) });
              sent[cp] = true;
            }
          });
          lastTime = player.currentTime;
        });
      });
    </script>

    <!-- Random background script -->
    <script>
      document.addEventListener('DOMContentLoaded', () => {
        const layer = document.querySelector('.bg-layer');
        if (!layer) return;
        const colors = [
          'rgba(255,90,255,0.08)',
          'rgba(0,255,190,0.06)',
          'rgba(180,100,255,0.07)',
          'rgba(120,255,180,0.05)',
          'rgba(255,180,255,0.04)'
        ];
        const shuffled = colors.sort(() => 0.5 - Math.random());
        const randomGradient = (color) => {
          const x = Math.floor(Math.random() * 100);
          const y = Math.floor(Math.random() * 100);
          const size = Math.floor(Math.random() * 40 + 60);
          return `radial-gradient(ellipse at ${x}% ${y}%, ${color}, transparent ${size}%)`;
        };
        const randomGradients = shuffled.map(c => randomGradient(c)).join(',');
        const darkSpace = 'linear-gradient(180deg, #03040a 0%, #050612 60%, #0a101a 100%)';
        layer.style.background = randomGradients + ',' + darkSpace;
        layer.style.backgroundBlendMode = 'screen, overlay, normal';
        layer.style.backgroundSize = '200% 200%';
        layer.style.animation = 'drift 25s ease-in-out infinite alternate';
      });
    </script>
  
    <script>
    const msgBox = document.getElementById('message');
    msgBox?.addEventListener('input', () => {
      localStorage.setItem('draftMessage', msgBox.value);
    });
    window.addEventListener('load', () => {
      const saved = localStorage.getItem('draftMessage');
      if (saved) msgBox.value = saved;
    });
    document.getElementById('contact-form')?.addEventListener('submit', () => {
      localStorage.removeItem('draftMessage');
    });
  </script>

  <script>
  document.addEventListener('DOMContentLoaded', () => {
    // initialize hearts: wire up clicks and hydrate from localStorage using global helpers
    document.querySelectorAll('.heart-btn').forEach(btn => {
      const episodeKey = btn.dataset.episode || 'current';
      const saved = localStorage.getItem(`liked_${episodeKey}`);
      if (saved === 'true') btn.classList.add('active');

      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const key = btn.dataset.episode || 'current';
        const label = btn.dataset.title || btn.getAttribute('aria-label') || key;
        toggleLike(key, label, btn);
      });
    });
  });
  </script>

</body>
</html>
